//
//  load_posts.c
//  CBlog
//
//  Created by Colin Luoma on 2016-05-05.
//  Copyright (c) 2016 Colin Luoma. All rights reserved.
//
//  Interface functions to SQLite3 database
//

#include "load_posts.h"

int post_count = 0;

// Callback function for use with exec.
// Loads each post into an array of struct Post
int callback(void *data, int argc, char **argv, char **azColName) {
    int i;
    // Recast void *data to *struct Post
    struct Post *post = data;
    
    // For each returned row
    for(i=0; i<argc; i++)
    {
        if (strcmp(azColName[i], "title") == 0)             // Post title
        {
            post[post_count].title = malloc(strlen(argv[i]) + 1);
            strcpy(post[post_count].title, argv[i]);
            post[post_count].title[strlen(argv[i])] = '\0';
        }
        else if (strcmp(azColName[i], "post_id") == 0)      // Post ID
        {
            post[post_count].post_id = atoi(argv[i]);
        }
        else if (strcmp(azColName[i], "text") == 0)         // Post text
        {
            post[post_count].text = malloc(strlen(argv[i]) + 1);
            strcpy(post[post_count].text, argv[i]);
            post[post_count].text[strlen(argv[i])] = '\0';
        }
        else if (strcmp(azColName[i], "time") == 0)         // Post time
        {
            post[post_count].time = malloc(strlen(argv[i]) + 1);
            strcpy(post[post_count].time, argv[i]);
            post[post_count].time[strlen(argv[i])] = '\0';
        }
    }
    post_count += 1;
    
    return 0;
}

// Helper function to open SQLite3 DB
sqlite3 *open_database() {
    sqlite3 *db;
    int rc;
    char *db_location = "/Users/colin/Documents/CBlog/server/personl_blog.db";
    
    /* Open connection to SQLite db */
    rc = sqlite3_open(db_location, &db);
    if( rc ){
        fprintf(stderr, "Can't open database: %s\n", sqlite3_errmsg(db));
        return NULL;
    }else{
        fprintf(stderr, "Opened database successfully\n");
        return db;
    }
}

// Used to edit and existing post, post_id is the primary key
// 0 - FAIL, 1 - SUCCESS
int update_post(char *post_id, char *post_title, char *post_text) {
    /* SQLite variable declarations */
    int rc;
    sqlite3_stmt *results;
    
    char *sql = "UPDATE posts SET title = ?, text = ? WHERE post_id = ?";
    
    /* Connect to DB */
    sqlite3 *db = open_database();
    if (db == NULL) {
        fprintf(stderr, "Failed to open DB connection.\n");
        return 0;
    }
    
    /* Prepare sql statement */
    rc = sqlite3_prepare_v2(db, sql, -1, &results, 0);
    
    // Bind input data to sql statement
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to update table: %s\n", sqlite3_errmsg(db));
        return 0;
    }
    sqlite3_bind_text(results, 1, post_title, (int)strlen(post_title), SQLITE_TRANSIENT);
    sqlite3_bind_text(results, 2, post_text, (int)strlen(post_text), SQLITE_TRANSIENT);
    sqlite3_bind_text(results, 3, post_id, (int)strlen(post_id), SQLITE_TRANSIENT);
    
    // Execute statement
    sqlite3_step(results);
    
    // Free statement, close DB
    sqlite3_finalize(results);
    sqlite3_close(db);
    
    return 1;
}

// Used to create a new post, post_id is automatically generated by the DB
int create_post(char *post_title, char *post_text) {
    /* SQLite variable declarations */
    int rc;
    sqlite3_stmt *results;
    
    char *sql = "INSERT INTO posts (title, text, time) VALUES(?, ?, (strftime('%s', 'now')))";
    
    /* Connect to DB */
    sqlite3 *db = open_database();
    if (db == NULL) {
        fprintf(stderr, "Failed to open DB connection.\n");
        return 0;
    }
    
    /* Prepare sql statement */
    rc = sqlite3_prepare_v2(db, sql, -1, &results, 0);
    
    // Bind input data to sql statement
    if (rc != SQLITE_OK) {
        fprintf(stderr, "Failed to update table: %s\n", sqlite3_errmsg(db));
        return 0;
    }
    sqlite3_bind_text(results, 1, post_title, (int)strlen(post_title), SQLITE_TRANSIENT);
    sqlite3_bind_text(results, 2, post_text, (int)strlen(post_text), SQLITE_TRANSIENT);
    
    // Execute statement
    sqlite3_step(results);
    
    // Free statement, close DB
    sqlite3_finalize(results);
    sqlite3_close(db);
    
    return 1;
}

// Used to remove a post
int delete_post(int post_id) {
    /* SQLite variable declarations */
    int rc;
    char sql[200];
    char *zErrMsg = 0;
    
    /* Create SQL statement */
    sprintf(sql, "DELETE FROM posts WHERE post_id = %d", post_id);
    
    /* Connect to DB */
    sqlite3 *db = open_database();
    
    /* Execute SQL statement */
    int success = 0;
    rc = sqlite3_exec(db, sql, NULL, NULL, &zErrMsg);
    if( rc != SQLITE_OK ){
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    }else{
        fprintf(stderr, "Operation done successfully\n");
        success = 1;
    }
    sqlite3_close(db);
    
    return success;
}

// Loads all posts inta a struct *post
// Packs the array of posts in a struct Posts, which is a struct
struct Posts load_posts(int number_of_posts, int offset) {
    
    // Allocate memory for post structs
    struct Post *all_posts = malloc(sizeof(struct Post) * number_of_posts);
    
    /* SQLite variable declarations */
    int rc;
    char sql[300];
    char *zErrMsg = 0;
    
    /* Create SQL statement */
    sprintf(sql, "SELECT title, post_id, text, datetime(time, 'unixepoch') AS time from posts order by time DESC limit %d offset %d", number_of_posts, offset);
    
    /* Connect to DB */
    sqlite3 *db = open_database();
    
    /* Execute SQL statement */
    rc = sqlite3_exec(db, sql, callback, all_posts, &zErrMsg);
    if( rc != SQLITE_OK ){
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    }else{
        fprintf(stderr, "Operation done successfully\n");
    }
    sqlite3_close(db);
    
    struct Posts posts;
    posts.number_of_posts = post_count;
    posts.posts = all_posts;
    
    return posts;
}

// Loads a single post with a given post_id
struct Post load_post_id(int post_id) {
    
    struct Post post;
    
    /* SQLite variable declarations */
    int rc;
    char sql[200];
    char *zErrMsg = 0;
    
    /* Create SQL statement */
    sprintf(sql, "SELECT title, post_id, text, datetime(time, 'unixepoch') AS time from posts where post_id = %d limit 1", post_id);
    
    /* Connect to DB */
    sqlite3 *db = open_database();
    
    /* Execute SQL statement */
    rc = sqlite3_exec(db, sql, callback, &post, &zErrMsg);
    if( rc != SQLITE_OK ){
        fprintf(stderr, "SQL error: %s\n", zErrMsg);
        sqlite3_free(zErrMsg);
    }else{
        fprintf(stderr, "Operation done successfully\n");
    }
    sqlite3_close(db);
    
    return post;
}

// Given a pointer to a single Post
void free_post(struct Post *post) {
    free(post[0].title);
    free(post[0].text);
    free(post[0].time);
}

// Given a pointer to a Posts struct, frees everything
void free_posts(struct Posts *posts) {
    for (int i = 0; i < posts->number_of_posts; i++) {
        free_post(posts->posts + i);
    }
    free(posts->posts);
}